% Phosphene_Size_vs_Eccentricity
%
% simulates phosphene size as a function of eccentricity and electrode size. 
% This code is pretty slow, so the first time you run this,
% set the number of eccList and radList to 3, and the nSamp 3. Once you
% know the code works you can change these
%
% written IF & GMB
%
% 25/02/2023 moved into clean folder (IF)
% 06/03/2023 added bosking/keliris functionality (IF)
% 12/07/2024 commented
% 29/07/2024 fixed plotting and commented ES

clear
close all


%% Define eccentricties and radii to compare
nSamp = 2; % we are going to re-estimate the size of the percept multiple times. Error bars pretty low with 25
eccList = exp(linspace(log(.5), log(35), 3)); % the eccentricities of the electrodes
radList =  exp(linspace(log(.05), log(5), 3)); % electrode size from teeny tiny to huge. These are radii, in cm units


%% generate cortical surface, visual map and pulse train
% define cortex

% define fall off constant
c.I_k = 1000;
% c.I_k = 1000 represents rapid fall off in the electric field as a function of distance from the electrode
% i.e. only stimulating directly under the electrode.
% c.I_k = 6.75 is the default value. It represents fall off in the electric field as a function of distance based on Tehovnik 2006
% https://doi.org/10.1152/jn.00126.2006

% define cortex dimensions
c.cortexHeight = [-10,10]; % degrees top to bottom, degrees LR,
c.cortexLength = [-80, 5];
c.pixpermm = 12; % default 6, resolution of electric field sampling, for very small electrodes may need to be decreased
c = p2p_c.define_cortex(c); % define the properties of the cortical map

% define the visual map
v.visfieldHeight = [-60,60];
v.visfieldWidth= [-60,60];
v.pixperdeg = 8;  %visual field map size and samping
v = p2p_c.define_visualmap(v); % defines the visual map

[c, v] = p2p_c.generate_corticalmap(c, v); % create ocular dominance/orientation/rf size maps on cortical surface
tp = p2p_c.define_temporalparameters(); % define the temporal model

% define pulse train
trl.amp = 300; trl.freq = 1;
trl.pw = 2*10^(-4);   trl.dur= 1;
trl = p2p_c.define_trial(tp,trl);


%% generate cortical electrical response and phosphenes
% Loop over each electrode radius and eccentricity combination
ct = 1;
for rad = 1:length(radList)
    disp([ 'size  = ', num2str(radList(rad))])
    for ecc = 1:length(eccList)
        disp([ 'eccentricity = ', num2str(eccList(ecc))])

        % set electrode properties
        c.e.radius =  radList(rad);
        v.e.ecc = eccList(ecc);
        v.e.ang = 0;

        % resample several times to estimate mean phosphene size
        for r = 1:nSamp 
            [c, v] = p2p_c.generate_corticalmap(c, v); % create ocular dominance/orientation/rf size maps on cortical surface
            [c, v] = p2p_c.define_electrodes(c, v); % complete properties for each electrode in cortical space
            c = p2p_c.generate_ef(c); % generate map of the electric field for each electrode on cortical surface
            v = p2p_c.generate_corticalelectricalresponse(c, v);  % create rf map for each electrode
            trl = p2p_c.generate_phosphene(v, tp, trl); % generate phosphene

            if r == 1 % plot first example phosphene
                str = ['subplot(', num2str(length(radList)), ',', num2str(length(eccList)), ',', num2str(ct), ')'];
                p2p_c.plotcortgrid(c.e.ef*256, c, gray(256), 1, str); drawnow;
                img = mean(trl.max_phosphene, 3); % average across cells representing LE and RE
                img = img./max(abs(img(:))); % normalize so max is 1
                img = (img+.5)*127; %  scale
                p2p_c.plotretgrid(img, v, gray(256), 2, str); drawnow;
                ct = ct+1;
            end
        end

        % so when we have a nice clean phosphene you can just calculate the
        % values that are above drawing threshold. But for these messy
        % phosphenes we will find the best fitting Gaussian, which is a
        % little more robust
        p.sigma = .5;
        p.x = v.e.x; 
        p.y = v.e.y;

        % fit a gaussian
        % optUW is a set of wrapper functions for fminsearch that makes it
        % easier to use
        [p, err] = optUW.fit(@p2p_c.fit_phosphene, p, {'sigma'}, trl, v);
        
        % store ellipse size, gaussian sigma, and radius and eccentricity
        ellipse(rad, ecc, r) = mean([trl.ellipse(1).sigma_x trl.ellipse(1).sigma_y]);
        sigma(rad, ecc, r) = p.sigma;
        radius(rad, ecc, r) = radList(rad);
        eccentricity(rad, ecc, r) = eccList(ecc);

        disp(r)
        fprintf('sigma: %.4f\n', p.sigma);
        disp(['sigma slice at r = ', num2str(r)]);
        disp(sigma(:, :, r));
    end
end


%% plot phosphene size as a function of eccentricity and electrode size
figure;

clist = parula(length(radList)+1); % generate colormap
hp = gobjects(length(radList),1);  % preallocate handles for legend

% for each rad/ecc combo
for rad = 1:length(radList)
    for ecc = 1:length(eccList)
        % generate mean and std
        mn_sigma(rad, ecc) = mean(sigma(rad, ecc, :));
        std_sigma(rad,ecc) = std(sigma(rad, ecc, :))*2; % two stds
    end

    % Plot mean phosphene size with colored lines and markers
    hp(rad) = plot(eccList, mn_sigma(rad, :), '.-',  ....
        'MarkerFaceColor', clist(rad,:), 'MarkerSize', 30, ...
        'LineStyle', '-', 'LineWidth', 2, 'MarkerEdgeColor', ...
        clist(rad,:), 'Color', clist(rad,:)); hold on

    % Add shaded error region (+/- 2 std)
    sh = shadedErrorBar(eccList, mn_sigma(rad, :),  std_sigma(rad, :));   
   
    sh.patch.FaceColor = clist(rad, :);
    sh.mainLine.Color = clist(rad, :);
    sh.edge(1).Color ='none';  sh.edge(2).Color = 'none';

end

% Add title and axis labels
title('phosphene size as a function of eccentricity and electrode size'); 
xlabel('eccentricity');
ylabel('mean phosphene size: \sigma +/- 2 std (degrees of visual space)');lg = legend(hp, cellstr(num2str(round(radList(:),2))));
lg.Title.String = 'Electrode Radius (cm)';


